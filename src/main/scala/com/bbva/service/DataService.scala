package com.bbva.service

import akka.actor.{ActorRef, ActorSystem, Props}
import akka.http.scaladsl.model.StatusCodes
import akka.http.scaladsl.model.headers.RawHeader
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.server.{Route, StandardRoute}
import akka.pattern.{Patterns, ask}
import akka.routing.FromConfig
import akka.util.Timeout
import com.bbva.App
import com.bbva.actor.{ProducerActorRabbit}
import com.bbva.model._
import com.rabbitmq.client.ConnectionFactory
import com.typesafe.config.Config

import scala.concurrent.{Await, Future}
import scala.concurrent.duration._

/**
  * Message to sent to Rabbit.
  *
  * @param topic   Destination exchange.
  * @param id      MessageId autogenerated.
  * @param message Message body.
  */
case class Message(topic: String, id: String, message: String)

case class DataService(system: ActorSystem, rabbitFactory: ConnectionFactory)
                      (implicit val config: Config) {

  implicit val timeout = Timeout(5 seconds)
  val actortype = config.getString("akka.actortype")

  def getRabbitRouter(): ActorRef ={
    system.actorOf(FromConfig.props(
      Props(classOf[ProducerActorRabbit],rabbitFactory,system)), "rabbitRouter")
  }
  // val router = if(actortype=="rabbit") getRabbitRouter else getMainRouter
  val router = getRabbitRouter
  val route: Route =
    pathPrefix("input-api") {
      path("healthCheck") {
        get {
          App.Stats.paintCount
          implicit val timeout = Timeout(5 seconds)
          val future = router ? "status"

          try{
            val result = Await.result(future, timeout.duration).asInstanceOf[Boolean]
            healthCheckResponse(
              "healthCheck",StatusCodes.OK.intValue,StatusCodes.OK.defaultMessage,
              result.toString,App.Stats.contrequest,App.Stats.contsend)
          }catch {
            case e: Exception =>
            healthCheckResponse(
              "healthCheck",StatusCodes.ServiceUnavailable.intValue,
              StatusCodes.ServiceUnavailable.defaultMessage,"KO",App.Stats.contrequest,
              App.Stats.contsend)
          }



        }
      } ~ path("bulk") {
        pathEndOrSingleSlash {
          post {
            entity(as[List[BulkLog]]) { events =>
              val uuids = events.map(event =>
                sendLogToProducer(event.sourceSystem, event.message))
              bulkResponse("bulk", uuids)
            }
          }
        }
      } ~
        pathPrefix("structured-logs") {
          pathEndOrSingleSlash {
            post {
              entity(as[String]) { event =>
                App.Stats.sumRequest()
                val uuid = sendLogToProducer("data", event)
                logResponse("structured-logs", uuid)
              }
            }
          }
        }
    }

  def sendLogToProducer(source: String, event: String) = {
    val newUUID = uuidGenerator
    router ! Message(config.getString("application.rabbitmq.exchange"), newUUID, event)
    newUUID
  }

  def logResponse(path: String, newUUID: String) = {
    val headers = List(
      RawHeader("Content-Location", s"/input-api/$path")
    )
    respondWithHeaders(headers) {
      complete((StatusCodes.Accepted, LogResponse(IdElement(newUUID))))
    }
  }

  def healthCheckResponse(path: String, apiStatusCode: Int,apiStatus: String, rabbitStatus: String,
                          numRequests: Long,  numSend: Long): Route = {
    val headers = List(
      RawHeader("Content-Location", s"/input-api/$path")
    )
    respondWithHeaders(headers) {
      complete(apiStatusCode, HealthCheckDataResponse(HealthCheckResponse(path,
        apiStatus, rabbitStatus, numRequests, numSend)))
    }
  }

  def bulkResponse(path: String, newUUIDs: List[String]) = {
    val headers = List(
      RawHeader("Content-Location", s"/input-api/$path")
    )
    respondWithHeaders(headers) {
      complete((StatusCodes.Accepted, BulkResponse(newUUIDs.map(IdElement(_)))))
    }
  }

  def uuidGenerator = java.util.UUID.randomUUID.toString

}
